import Foundation

/// A file generated by the code generator.
struct GeneratedFile {
    let path: String
    let content: String
}

/// Generates Swift source code from parsed ``LexiconDocument`` values.
struct SwiftCodeGenerator {

    let namingStrategy: NamingStrategy
    let typeMapper: TypeMapper
    var accessLevel: String = "public"

    // MARK: - Top-level Entry Point

    /// Generate Swift source files for a collection of lexicon documents.
    func generate(documents: [LexiconDocument]) -> [GeneratedFile] {
        documents.compactMap { generateFile(for: $0) }
    }

    /// Generate a single Swift file for one lexicon document.
    func generateFile(for document: LexiconDocument) -> GeneratedFile? {
        var sections: [String] = []

        let header = generateHeader(for: document)
        sections.append(header)

        // Sort definition keys for deterministic output.
        let sortedDefs = document.defs.sorted { $0.key < $1.key }

        for (defName, def) in sortedDefs {
            switch def {
            case .record(let recordDef):
                let name = namingStrategy.structName(for: document.id, defName: defName)
                sections.append(generateRecord(name: name, def: recordDef, nsid: document.id))

            case .query(let queryDef):
                let name = namingStrategy.structName(for: document.id, defName: defName)
                sections.append(generateQuery(name: name, def: queryDef, nsid: document.id))

            case .procedure(let procedureDef):
                let name = namingStrategy.structName(for: document.id, defName: defName)
                sections.append(generateProcedure(name: name, def: procedureDef, nsid: document.id))

            case .subscription(let subscriptionDef):
                let name = namingStrategy.structName(for: document.id, defName: defName)
                sections.append(generateSubscription(name: name, def: subscriptionDef, nsid: document.id))

            case .object(let objectDef):
                let name = namingStrategy.structName(for: document.id, defName: defName)
                sections.append(generateObject(name: name, def: objectDef, nsid: document.id))

            case .string(let stringDef):
                let name = namingStrategy.structName(for: document.id, defName: defName)
                if let knownValues = stringDef.knownValues, !knownValues.isEmpty {
                    sections.append(generateStringEnum(name: name, values: knownValues))
                } else {
                    sections.append(generateTypealias(name: name, swiftType: "String", description: stringDef.description))
                }

            case .token(let tokenDef):
                let name = namingStrategy.structName(for: document.id, defName: defName)
                sections.append(generateToken(name: name, def: tokenDef, nsid: document.id))

            case .array(let arrayDef):
                let name = namingStrategy.structName(for: document.id, defName: defName)
                let itemType = typeMapper.mapPropertyType(arrayDef.items, required: true, currentNSID: document.id)
                sections.append(generateTypealias(name: name, swiftType: "[\(itemType)]", description: arrayDef.description))
            }
        }

        let fileName = namingStrategy.fileName(for: document.id)
        let content = sections.joined(separator: "\n\n") + "\n"
        return GeneratedFile(path: fileName, content: content)
    }

    // MARK: - Header

    private func generateHeader(for document: LexiconDocument) -> String {
        var lines: [String] = []
        lines.append("// Generated by lexigen - do not edit")
        lines.append("// Source: \(document.id)")
        lines.append("")
        lines.append("import Foundation")
        lines.append("import ATProtoCore")
        return lines.joined(separator: "\n")
    }

    // MARK: - Record

    func generateRecord(name: String, def: RecordDef, nsid: String) -> String {
        var lines: [String] = []
        if let desc = def.description {
            lines.append(docComment(desc))
        }
        lines.append("\(accessLevel) struct \(name): Codable, Sendable {")
        lines.append("    \(accessLevel) static let typeIdentifier = \"\(nsid)\"")
        lines.append("")
        lines.append(contentsOf: generateObjectProperties(def.record, nsid: nsid))
        lines.append("")
        lines.append(contentsOf: generateObjectInit(def.record, nsid: nsid, accessLevel: accessLevel))
        lines.append("")
        lines.append(contentsOf: generateCodingKeys(def.record))
        lines.append("}")
        return lines.joined(separator: "\n")
    }

    // MARK: - Query

    func generateQuery(name: String, def: QueryDef, nsid: String) -> String {
        var lines: [String] = []
        if let desc = def.description {
            lines.append(docComment(desc))
        }
        lines.append("\(accessLevel) enum \(name) {")
        lines.append("    \(accessLevel) static let methodIdentifier = \"\(nsid)\"")

        // Parameters struct
        if let params = def.parameters, let props = params.properties, !props.isEmpty {
            lines.append("")
            lines.append("    \(accessLevel) struct Parameters: Codable, Sendable {")
            let paramObj = ObjectDef(
                type: "object",
                description: nil,
                required: params.required,
                nullable: nil,
                properties: params.properties
            )
            lines.append(contentsOf: generateObjectProperties(paramObj, nsid: nsid, indent: "        "))
            lines.append("")
            lines.append(contentsOf: generateObjectInit(paramObj, nsid: nsid, accessLevel: accessLevel, indent: "        "))
            lines.append("")
            lines.append(contentsOf: generateCodingKeys(paramObj, indent: "        "))
            lines.append("    }")
        }

        // Output struct
        if let output = def.output, let schema = output.schema {
            lines.append("")
            lines.append(contentsOf: generateInlineSchema(name: "Output", schema: schema, nsid: nsid, indent: "    "))
        }

        // Errors enum
        if let errors = def.errors, !errors.isEmpty {
            lines.append("")
            lines.append(contentsOf: generateErrorsEnum(errors, indent: "    "))
        }

        lines.append("}")
        return lines.joined(separator: "\n")
    }

    // MARK: - Procedure

    func generateProcedure(name: String, def: ProcedureDef, nsid: String) -> String {
        var lines: [String] = []
        if let desc = def.description {
            lines.append(docComment(desc))
        }
        lines.append("\(accessLevel) enum \(name) {")
        lines.append("    \(accessLevel) static let methodIdentifier = \"\(nsid)\"")

        // Input struct
        if let input = def.input, let schema = input.schema {
            lines.append("")
            lines.append(contentsOf: generateInlineSchema(name: "Input", schema: schema, nsid: nsid, indent: "    "))
        }

        // Output struct
        if let output = def.output, let schema = output.schema {
            lines.append("")
            lines.append(contentsOf: generateInlineSchema(name: "Output", schema: schema, nsid: nsid, indent: "    "))
        }

        // Errors enum
        if let errors = def.errors, !errors.isEmpty {
            lines.append("")
            lines.append(contentsOf: generateErrorsEnum(errors, indent: "    "))
        }

        lines.append("}")
        return lines.joined(separator: "\n")
    }

    // MARK: - Subscription

    func generateSubscription(name: String, def: SubscriptionDef, nsid: String) -> String {
        var lines: [String] = []
        if let desc = def.description {
            lines.append(docComment(desc))
        }
        lines.append("\(accessLevel) enum \(name) {")
        lines.append("    \(accessLevel) static let methodIdentifier = \"\(nsid)\"")

        // Parameters struct
        if let params = def.parameters, let props = params.properties, !props.isEmpty {
            lines.append("")
            lines.append("    \(accessLevel) struct Parameters: Codable, Sendable {")
            let paramObj = ObjectDef(
                type: "object",
                description: nil,
                required: params.required,
                nullable: nil,
                properties: params.properties
            )
            lines.append(contentsOf: generateObjectProperties(paramObj, nsid: nsid, indent: "        "))
            lines.append("")
            lines.append(contentsOf: generateObjectInit(paramObj, nsid: nsid, accessLevel: accessLevel, indent: "        "))
            lines.append("")
            lines.append(contentsOf: generateCodingKeys(paramObj, indent: "        "))
            lines.append("    }")
        }

        // Message schema
        if let message = def.message, let schema = message.schema {
            lines.append("")
            lines.append(contentsOf: generateInlineSchema(name: "Message", schema: schema, nsid: nsid, indent: "    "))
        }

        lines.append("}")
        return lines.joined(separator: "\n")
    }

    // MARK: - Object

    func generateObject(name: String, def: ObjectDef, nsid: String) -> String {
        var lines: [String] = []
        if let desc = def.description {
            lines.append(docComment(desc))
        }
        lines.append("\(accessLevel) struct \(name): Codable, Sendable {")
        lines.append(contentsOf: generateObjectProperties(def, nsid: nsid))
        lines.append("")
        lines.append(contentsOf: generateObjectInit(def, nsid: nsid, accessLevel: accessLevel))
        lines.append("")
        lines.append(contentsOf: generateCodingKeys(def))
        lines.append("}")
        return lines.joined(separator: "\n")
    }

    // MARK: - Union

    func generateUnion(name: String, refs: [String], closed: Bool, nsid: String) -> String {
        var lines: [String] = []
        lines.append("\(accessLevel) enum \(name): Codable, Sendable {")
        for ref in refs {
            let typeName = typeMapper.mapRef(ref, currentNSID: nsid)
            let caseName = unionCaseName(from: ref)
            lines.append("    case \(caseName)(\(typeName))")
        }
        if !closed {
            lines.append("    case unexpected(LexiconValue)")
        }
        lines.append("}")
        return lines.joined(separator: "\n")
    }

    // MARK: - String Enum

    func generateStringEnum(name: String, values: [String]) -> String {
        var lines: [String] = []
        lines.append("\(accessLevel) enum \(name): String, Codable, Sendable, CaseIterable {")
        for value in values {
            let caseName = namingStrategy.enumCaseName(value)
            lines.append("    case \(caseName) = \"\(value)\"")
        }
        lines.append("}")
        return lines.joined(separator: "\n")
    }

    // MARK: - Token

    private func generateToken(name: String, def: TokenDef, nsid: String) -> String {
        var lines: [String] = []
        if let desc = def.description {
            lines.append(docComment(desc))
        }
        lines.append("\(accessLevel) enum \(name) {")
        lines.append("    \(accessLevel) static let tokenIdentifier = \"\(nsid)\"")
        lines.append("}")
        return lines.joined(separator: "\n")
    }

    // MARK: - Typealias

    private func generateTypealias(name: String, swiftType: String, description: String?) -> String {
        var lines: [String] = []
        if let desc = description {
            lines.append(docComment(desc))
        }
        lines.append("\(accessLevel) typealias \(name) = \(swiftType)")
        return lines.joined(separator: "\n")
    }

    // MARK: - Inline Schema

    /// Generate a nested struct from an inline schema (e.g. output/input schemas).
    private func generateInlineSchema(name: String, schema: PropertyDef, nsid: String, indent: String) -> [String] {
        var lines: [String] = []
        switch schema {
        case .ref(let refDef):
            lines.append("\(indent)\(accessLevel) typealias \(name) = \(typeMapper.mapRef(refDef.ref, currentNSID: nsid))")
        case .union(let unionDef):
            lines.append("\(indent)\(accessLevel) enum \(name): Codable, Sendable {")
            for ref in unionDef.refs {
                let typeName = typeMapper.mapRef(ref, currentNSID: nsid)
                let caseName = unionCaseName(from: ref)
                lines.append("\(indent)    case \(caseName)(\(typeName))")
            }
            if unionDef.closed != true {
                lines.append("\(indent)    case unexpected(LexiconValue)")
            }
            lines.append("\(indent)}")
        default:
            // For object-like schemas embedded directly, generate a struct.
            lines.append("\(indent)\(accessLevel) struct \(name): Codable, Sendable {")
            lines.append("\(indent)    // TODO: Inline schema generation")
            lines.append("\(indent)}")
        }
        return lines
    }

    // MARK: - Errors Enum

    private func generateErrorsEnum(_ errors: [ErrorDef], indent: String) -> [String] {
        var lines: [String] = []
        lines.append("\(indent)\(accessLevel) enum Error: String, Swift.Error, Sendable {")
        for error in errors {
            let caseName = namingStrategy.enumCaseName(error.name)
            if let desc = error.description {
                lines.append("\(indent)    /// \(desc)")
            }
            lines.append("\(indent)    case \(caseName) = \"\(error.name)\"")
        }
        lines.append("\(indent)}")
        return lines
    }

    // MARK: - Object Helpers

    /// Generate property declarations for an object definition.
    private func generateObjectProperties(_ obj: ObjectDef, nsid: String, indent: String = "    ") -> [String] {
        guard let properties = obj.properties else { return [] }
        let requiredSet = Set(obj.required ?? [])
        var lines: [String] = []
        for (key, prop) in properties.sorted(by: { $0.key < $1.key }) {
            let isRequired = requiredSet.contains(key)
            let swiftType = typeMapper.mapPropertyType(prop, required: isRequired, currentNSID: nsid)
            let propName = namingStrategy.propertyName(key)

            if let desc = propertyDescription(prop) {
                lines.append("\(indent)/// \(desc)")
            }
            lines.append("\(indent)\(accessLevel) let \(propName): \(swiftType)")
        }
        return lines
    }

    /// Generate a memberwise initializer for an object.
    private func generateObjectInit(
        _ obj: ObjectDef,
        nsid: String,
        accessLevel: String,
        indent: String = "    "
    ) -> [String] {
        guard let properties = obj.properties, !properties.isEmpty else {
            return ["\(indent)\(accessLevel) init() {}"]
        }
        let requiredSet = Set(obj.required ?? [])
        var params: [String] = []
        var assignments: [String] = []

        for (key, prop) in properties.sorted(by: { $0.key < $1.key }) {
            let isRequired = requiredSet.contains(key)
            let swiftType = typeMapper.mapPropertyType(prop, required: isRequired, currentNSID: nsid)
            let propName = namingStrategy.propertyName(key)
            let defaultValue = isRequired ? "" : " = nil"
            params.append("\(propName): \(swiftType)\(defaultValue)")
            assignments.append("\(indent)    self.\(propName) = \(propName)")
        }

        var lines: [String] = []
        if params.count == 1 {
            lines.append("\(indent)\(accessLevel) init(\(params[0])) {")
        } else {
            lines.append("\(indent)\(accessLevel) init(")
            for (index, param) in params.enumerated() {
                let separator = index < params.count - 1 ? "," : ""
                lines.append("\(indent)    \(param)\(separator)")
            }
            lines.append("\(indent)) {")
        }
        lines.append(contentsOf: assignments)
        lines.append("\(indent)}")
        return lines
    }

    /// Generate a CodingKeys enum when property names differ from JSON keys.
    private func generateCodingKeys(_ obj: ObjectDef, indent: String = "    ") -> [String] {
        guard let properties = obj.properties, !properties.isEmpty else { return [] }
        var needsCodingKeys = false
        var entries: [(caseName: String, rawValue: String)] = []

        for key in properties.keys.sorted() {
            let propName = namingStrategy.propertyName(key)
            // Strip backticks for comparison.
            let cleanPropName = propName.replacingOccurrences(of: "`", with: "")
            if cleanPropName != key {
                needsCodingKeys = true
            }
            entries.append((caseName: cleanPropName, rawValue: key))
        }

        guard needsCodingKeys else { return [] }

        var lines: [String] = []
        lines.append("\(indent)private enum CodingKeys: String, CodingKey {")
        for entry in entries {
            if entry.caseName == entry.rawValue {
                lines.append("\(indent)    case \(entry.caseName)")
            } else {
                lines.append("\(indent)    case \(entry.caseName) = \"\(entry.rawValue)\"")
            }
        }
        lines.append("\(indent)}")
        return lines
    }

    // MARK: - Utilities

    /// Build a doc-comment string (`/// ...`) from a description.
    private func docComment(_ text: String) -> String {
        text.split(separator: "\n", omittingEmptySubsequences: false)
            .map { "/// \($0)" }
            .joined(separator: "\n")
    }

    /// Extract the description from a property definition, if present.
    private func propertyDescription(_ prop: PropertyDef) -> String? {
        switch prop {
        case .string(let d):   return d.description
        case .integer(let d):  return d.description
        case .boolean(let d):  return d.description
        case .array(let d):    return d.description
        case .ref(let d):      return d.description
        case .union(let d):    return d.description
        case .blob(let d):     return d.description
        case .bytes(let d):    return d.description
        case .cidLink(let d):  return d.description
        case .unknown(let d):  return d.description
        }
    }

    /// Derive a union case name from a ref string.
    ///
    /// For example `"app.bsky.feed.defs#feedViewPost"` becomes `feedViewPost`,
    /// and `"com.atproto.repo.strongRef"` becomes `comAtprotoRepoStrongRef`.
    private func unionCaseName(from ref: String) -> String {
        if let hashIndex = ref.lastIndex(of: "#") {
            let fragment = String(ref[ref.index(after: hashIndex)...])
            return namingStrategy.enumCaseName(fragment)
        }
        // No fragment â€” derive from the full NSID.
        let parts = ref.split(separator: ".")
        guard let last = parts.last else { return "unknown" }
        return namingStrategy.enumCaseName(String(last))
    }
}
